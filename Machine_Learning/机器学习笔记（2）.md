---
title: 《机器学习实战》《西瓜书》笔记（二）- 模型评估与选择
date: 2019-11-26 15:30
categories: Machine_Learning
tags: ML
---
# 《机器学习实战》《西瓜书》笔记（二）- 模型评估与选择
## 经验误差与过拟合
- **错误率与精度**
错误率是分类错误的样本数占样本总数的比例，精度是分类正确的样本数占样本总数的比例。
- **误差与经验误差**
学习器的实际预测输出与样本的真实输出之间的差异称为“误差”，学习器在训练集上的误差称为训练误差/经验误差，在新样本上的误差称为“泛化误差”。
- **过拟合与欠拟合**
然而，当学习器把训练样本学得"太 好"了的时候，很可能巳经把训练样本自身的一些特点当作了所有潜在样本都 会具有的一般性质，这样就会导致泛化性能下降，叫做 **过拟合（overfitting)**
训练样本的一般性质尚未学好叫做 **欠拟合**
<div align = center>
<img src= "https://img.vim-cn.com/30/0e0722ac9770db63a1185dd505a770f82ec37a.png">
</div>

## 评估方法
通常我们使用测试集上样本产生的泛化误差作为评估标准，就是以“测试误差”来代表学习器的“泛化误差”
## 划分数据集(D)与测试机(T)的常用方法
### 留出法
“留出法”直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为训练集T。训练/测试集的划分要尽可能保持数据分布的一致性，例如在分类任务中至少要保持样本的类别比例相似。如果从采样的角度来看待数据集的划分过程，则保留类别比例的采样方式通常称为“分层采样”。
单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。通常将2/3~4/5的样本用于训练，剩余样本用于测试。
### 交叉验证法
先将数据集D划分为k个大小相似的互斥子集，每个子集都尽可能保持数据分布的一致性，即从D中通过分层采样得到，然后，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。
交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值，通常又称为“k折交叉验证”。与留出法相似，将数据集划分为k个子集同样存在多种划分方式，为减少因样本划分不同而引入的差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的均值。
假定数据集中包含m个样本，若令k=m，则得到了交叉验证法的一个特例：留一法。
<div align = center>
<img src = "https://img.vim-cn.com/a3/a25652e1f7a9e0ef4038c3fbf67f4d31bc04be.png">
</div>

### 自助法
为减少训练样本规模不同造成的影响，同时比较高效地进行实验估计。自助法（bootstrapping）以自助采样法为基础。给定包含m个样本的数据集D，我们对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，我们就得到了包含m个样本的数据集D’。显然，D中有一部分样本在D’中多次出现，而一部分样本不出现。通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D’中。于是将D’用作训练集，D/D’用作测试集。这样的测试结果，亦称“包外估计”。
没有留出法，和交叉验证法常用

## 调参与最终模型
大多数学习算法都有些参数(parameter)需要设定，参数配置不同，学得模 型的性能往往有显著差别.因此，在进行模型评估与选择时，除了要对适用学习 算法进行选择，还需对算法参数进行设定，这就是通常所说的"参数调节"或 简称"调参" (parameter tuning).
现实中常用的做法?是对每个参数选定一个 范围和变化步长，例如在 [0 ，0.2] 范围内以 0.05 为步长，则实际要评估的候选参 数值有 5 个，最终是从这 5 个候选值中产生选定值.显然，这样选定的参数值往 往不是"最佳"值，但这是在计算开销和性能估计之间进行折中的结果，通过 这个折中，学习过程才变得可行.事实上，即便在进行这样的折中后，调参往往 仍很困难.可以简单估算一下:假定算法有 3 个参数，每个参数仅考虑 5 个候选 值，这样对每一组训练/测试集就有 53 = 125 个模型需考察
另外，需注意的是，我们通常把学得模型在实际使用中遇到的数据称为测 试数据，为了加以区分，模型评估与选择中用于评估测试的数据集常称为"验 证集" (validation set). 例如，在研究对比不同算法的泛化性能时，我们用测试 集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分 为训练集和验证集，基于验证集上的性能来进行模型选择和调参.

## 性能度量
对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需 要有衡量模型泛化能力的评价标准，这就是性能度量(performance measure).
### 错误率与精度
错误率是分类错误的样本数占样本总数的比例，精度是分类正确的样本数占样本总数的比例。
### 查准率、查全率、F1
对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive)、假正例(false positive)、真反倒(true negative) 、 假反例(false negative)四种情形，令 TP、 FP、 TN、 FN 分别表示其对应的 样例数，则显然有 TP+FP+TN+FN=样例总数.分类结果的"泪淆矩 阵" (co时usion matrix),如下表所示
<div align = center>
<img src = "https://img.vim-cn.com/42/14fe59f1eb909caaeb22588f2f4594c29c6682.png">
</div>
准率和查全率是一对矛盾的度量。查准率-查全率曲线，简称“P-R曲线”。在进行比较时，若一个学习器的P-R曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者。如果两个学习器的P-R曲线交叉，难以一般性断言两者孰优孰劣。比较合理的判据是比较P-R曲线下面积的大小。
为综合考虑查准率、查全率的性能度量，“平衡点”即“查准率=查全率”时的取值，更常用的是F1度量。
当对查准率和查全率的重视程度有所不同，F1度量的一般形式Fβ.　β>0度量了查全率对查准率的相对重要性。β=1时退化为标准的F1，β>1时查全率有更大影响，β<1,查准率有更大影响。
对于有多个二分类混淆矩阵，可以在各混淆矩阵上分别计算查准率和查全率，再计算平均值，这样就得到“宏查准率”、“宏查全率”以及“宏F1”；还可将各混淆矩阵的对应元素进行平均，得到TP、FP、TN、 FN的平均值，再基于这些平均值计算出“微查准率”、“微查全率”和“微F1”。
<div align = center>
<img src = "https://img.vim-cn.com/4e/de127ae4820dca223d54d1e8cf1fb9eab42d37.png">
</div>

### ROC 与 RUC
很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与 神经网络参几第 5 章
一个分类阔值(threshold)进行比较，若大于|词值则分为正类，否则为反类.例 如，神经网络在一般情形下是对每个测试样本预测出一个 [0.0 ，1.0] 之间的实值， 然后将这个值与 0.5 进行比较，大于 0.5 则判为正例，否则为反例.这个实值或 概率预测结果的好坏，直接决定了学习器的泛化能力.实际上?根据这个实值或 概率预测结果，我们可将测试样本进行排序，"最可能"是正例的排在最前面， "最不可能"是正例的排在最后面.这样，分类过程就相当于在这个排序中以 某个"截断点" (cut point)将样本分为两部分，前一部分判作正例，后一部分则 判作反例.
我们根据学习器的预 测结果对样例进行排序，按此顺序逐个把样本作为正例进行预测，每次计算 出两个重要量的值，分别以它们为横、纵坐标作图'就得到了 "ROC 曲线 与 P卫-R 曲线使用查准率、查全率为纵、横轴不同， ROC 曲线的纵轴是"真正 例率" (True Positive Rate，简称 TPR)，横轴是"假正例率" (False Positive Rate，简称 FPR)，基于表 2.1 中的符号，两者分别定义为,
$TPR= \frac{TP} {TP+FN}$
$FPR= \frac{FP} {TN+FP}$

进行学习器的比较时， 与 P-R 图相似， 若一个学习器的 ROC 曲线被另一
个学习器的曲线完全"包住"， 则可断言后者的性能优于前者;若两个学习器 的 ROC 曲线发生交叉，则难以-般性地断言两者孰优孰劣. 此时如果一定要进 行比较， 则较为合理的判据是比较 ROC 曲线下的面积，即 AUC (Area Under ROC Curve)
### 代价敏感错误率与代价曲线
<div align = center>
<img src = "https://img.vim-cn.com/a7/92725fd772dbf66d9a108906ca5154fa42081a.png">
</div>
<div align = center>
<img src = "https://img.vim-cn.com/1b/655c2c88f7541eaef782c9fc1b2611c6174fc8.png">
</div>
<div align = center>
<img src = "https://img.vim-cn.com/08/4616ba375fc1fdf425257fe78da623dd23ce4d.png">
</div>

### 比较检验
有了实验评估方法和性能度量，看起来就能对学习器的性能进行评估比较 了:先使用某种实验评估方法测得学习器的某个性能度量结果，然后对这些结 果进行比较.但怎么来做这个"比较"呢?是直接取得性能度量的值然后"比 大小"吗?实际上，机器学习中性能比较这件事要比大家想象的复杂得多.这 里面涉及几个重要因素:首先，我们希望比较的是泛化性能，然而通过实验评估 方法我们获得的是测试集上的性能，两者的对比结果可能未必相同;第二，测试 集上的性能与测试集本身的选择有很大关系，且不论使用不同大小的测试集会 得到不同的结果，即使用相同大小的测试集?若包含的测试样例不同，测试结果 也会有不同;第二，很多机器学习算法本身有一定的随机性，即便用相同的参数 设置在同一个测试集上多次运行，其结果也会有不同.那么，有没有适当的方法 对学习器的性能进行比较呢? 统计假设检验(hypothesis test)为我们进行学习器t性能比较提供了重要依 据.基于假设检验结果我们可推断出，若在测试集上观察到学习器 A 比 B 好， 则 A 的泛化性能是否在统计意义上优于 B，以及这个结论的把握有多大.下面 我们先介绍两种最基本的假设检验，然后介绍几种常用的机器学习性能比较方 法.为便于讨论，本节默认以错误率为性能度量，用 E 表示.
### 偏差与方差
偏差方差分解试图对学习算法的期望泛化错误率进行拆解.我们知道，算 法在不同训练集上学得的结果很可能不同，即便这些训练集是来自同一个分布. 对测试样本队令 YD 为 m 在数据集中的标记， y 为 2 的真实标记， f(x; D) 为训 练集 D 上学得模型 f 在 m 上的预测输出.
**期望输出与真实标记的差别称为偏差(bias)**
<div align = center>
<img src = "https://img.vim-cn.com/11/682d2fceff5b7f82736f9d08f3646f50cc1fe3.png">
</div>

**泛化误差为偏差与噪声值与方差之和**
<div align = center>
<img src = "https://img.vim-cn.com/5e/aa3982956888fcbd37ef36f06d6cde0e0c4b36.png">
</div>